// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: doc.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1001000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(8240742d82741c9f);
CAPNP_DECLARE_SCHEMA(b99be59a8b091a34);
CAPNP_DECLARE_SCHEMA(c590e91773c0e1bd);
enum class Color_c590e91773c0e1bd: uint16_t {
  LABEL_COLOR,
  SECONDARY_LABEL_COLOR,
  TERTIARY_LABEL_COLOR,
  QUATERNARY_LABEL_COLOR,
  QUINARY_LABEL_COLOR,
  SYSTEM_RED_COLOR,
  SYSTEM_GREEN_COLOR,
  SYSTEM_BLUE_COLOR,
  SYSTEM_ORANGE_COLOR,
  SYSTEM_YELLOW_COLOR,
};
CAPNP_DECLARE_ENUM(Color, c590e91773c0e1bd);
CAPNP_DECLARE_SCHEMA(e4f632ee26727637);
CAPNP_DECLARE_SCHEMA(c17f4f909c2dd4a4);
CAPNP_DECLARE_SCHEMA(a90045c95d737675);
CAPNP_DECLARE_SCHEMA(c0480e8b33be07d6);
CAPNP_DECLARE_SCHEMA(d6971231e8f4929d);
CAPNP_DECLARE_SCHEMA(995419f6ec4a0246);
CAPNP_DECLARE_SCHEMA(d436c48fdf4276c0);
CAPNP_DECLARE_SCHEMA(f33943ca85905140);
CAPNP_DECLARE_SCHEMA(81cd1eb4338bf5bb);
CAPNP_DECLARE_SCHEMA(bf4cf8652eeb0286);
CAPNP_DECLARE_SCHEMA(8861bb7bdcf45af5);
CAPNP_DECLARE_SCHEMA(859a476891abdccd);
CAPNP_DECLARE_SCHEMA(c4023cc0b720250d);
CAPNP_DECLARE_SCHEMA(cd80be5f2dcbef04);
CAPNP_DECLARE_SCHEMA(f5664a42a3258ef6);

}  // namespace schemas
}  // namespace capnp


struct FontProperties {
  FontProperties() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8240742d82741c9f, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ColorValue {
  ColorValue() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b99be59a8b091a34, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

typedef ::capnp::schemas::Color_c590e91773c0e1bd Color;

struct Attribute {
  Attribute() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    FONT,
    FOREGROUND_COLOR,
    BACKGROUND_COLOR,
    UNDERLINE,
    STRIKETHROUGH,
    SUPERSCRIPT,
    SUBSCRIPT,
    LINK,
    PARAGRAPH,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e4f632ee26727637, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ParagraphStyle {
  ParagraphStyle() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c17f4f909c2dd4a4, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CommandData {
  CommandData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a90045c95d737675, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RangeAttributesPair {
  RangeAttributesPair() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0480e8b33be07d6, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LibraryEntry {
  LibraryEntry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d6971231e8f4929d, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LibraryRegistry {
  LibraryRegistry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(995419f6ec4a0246, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LocationDataPair {
  LocationDataPair() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d436c48fdf4276c0, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PlatformUrlPair {
  PlatformUrlPair() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f33943ca85905140, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct OuterDocMultiAttachment {
  OuterDocMultiAttachment() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(81cd1eb4338bf5bb, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct OuterDocPlugin {
  OuterDocPlugin() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bf4cf8652eeb0286, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct OuterLoopAttributedString {
  OuterLoopAttributedString() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8861bb7bdcf45af5, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UUID {
  UUID() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(859a476891abdccd, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RangeIDPair {
  RangeIDPair() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c4023cc0b720250d, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LocationCanvasPair {
  LocationCanvasPair() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cd80be5f2dcbef04, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RuntimeOuterDoc {
  RuntimeOuterDoc() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f5664a42a3258ef6, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class FontProperties::Reader {
public:
  typedef FontProperties Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFamily() const;
  inline  ::capnp::Text::Reader getFamily() const;

  inline float getSize() const;

  inline  ::uint32_t getWeight() const;

  inline bool getItalic() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FontProperties::Builder {
public:
  typedef FontProperties Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFamily();
  inline  ::capnp::Text::Builder getFamily();
  inline void setFamily( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFamily(unsigned int size);
  inline void adoptFamily(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFamily();

  inline float getSize();
  inline void setSize(float value);

  inline  ::uint32_t getWeight();
  inline void setWeight( ::uint32_t value);

  inline bool getItalic();
  inline void setItalic(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FontProperties::Pipeline {
public:
  typedef FontProperties Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ColorValue::Reader {
public:
  typedef ColorValue Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getRed() const;

  inline  ::uint8_t getGreen() const;

  inline  ::uint8_t getBlue() const;

  inline  ::uint8_t getAlpha() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ColorValue::Builder {
public:
  typedef ColorValue Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getRed();
  inline void setRed( ::uint8_t value);

  inline  ::uint8_t getGreen();
  inline void setGreen( ::uint8_t value);

  inline  ::uint8_t getBlue();
  inline void setBlue( ::uint8_t value);

  inline  ::uint8_t getAlpha();
  inline void setAlpha( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ColorValue::Pipeline {
public:
  typedef ColorValue Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Attribute::Reader {
public:
  typedef Attribute Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isFont() const;
  inline bool hasFont() const;
  inline  ::FontProperties::Reader getFont() const;

  inline bool isForegroundColor() const;
  inline  ::Color getForegroundColor() const;

  inline bool isBackgroundColor() const;
  inline bool hasBackgroundColor() const;
  inline  ::ColorValue::Reader getBackgroundColor() const;

  inline bool isUnderline() const;
  inline bool getUnderline() const;

  inline bool isStrikethrough() const;
  inline bool getStrikethrough() const;

  inline bool isSuperscript() const;
  inline bool getSuperscript() const;

  inline bool isSubscript() const;
  inline bool getSubscript() const;

  inline bool isLink() const;
  inline bool hasLink() const;
  inline  ::capnp::Text::Reader getLink() const;

  inline bool isParagraph() const;
  inline bool hasParagraph() const;
  inline  ::ParagraphStyle::Reader getParagraph() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Attribute::Builder {
public:
  typedef Attribute Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isFont();
  inline bool hasFont();
  inline  ::FontProperties::Builder getFont();
  inline void setFont( ::FontProperties::Reader value);
  inline  ::FontProperties::Builder initFont();
  inline void adoptFont(::capnp::Orphan< ::FontProperties>&& value);
  inline ::capnp::Orphan< ::FontProperties> disownFont();

  inline bool isForegroundColor();
  inline  ::Color getForegroundColor();
  inline void setForegroundColor( ::Color value);

  inline bool isBackgroundColor();
  inline bool hasBackgroundColor();
  inline  ::ColorValue::Builder getBackgroundColor();
  inline void setBackgroundColor( ::ColorValue::Reader value);
  inline  ::ColorValue::Builder initBackgroundColor();
  inline void adoptBackgroundColor(::capnp::Orphan< ::ColorValue>&& value);
  inline ::capnp::Orphan< ::ColorValue> disownBackgroundColor();

  inline bool isUnderline();
  inline bool getUnderline();
  inline void setUnderline(bool value);

  inline bool isStrikethrough();
  inline bool getStrikethrough();
  inline void setStrikethrough(bool value);

  inline bool isSuperscript();
  inline bool getSuperscript();
  inline void setSuperscript(bool value);

  inline bool isSubscript();
  inline bool getSubscript();
  inline void setSubscript(bool value);

  inline bool isLink();
  inline bool hasLink();
  inline  ::capnp::Text::Builder getLink();
  inline void setLink( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initLink(unsigned int size);
  inline void adoptLink(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownLink();

  inline bool isParagraph();
  inline bool hasParagraph();
  inline  ::ParagraphStyle::Builder getParagraph();
  inline void setParagraph( ::ParagraphStyle::Reader value);
  inline  ::ParagraphStyle::Builder initParagraph();
  inline void adoptParagraph(::capnp::Orphan< ::ParagraphStyle>&& value);
  inline ::capnp::Orphan< ::ParagraphStyle> disownParagraph();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Attribute::Pipeline {
public:
  typedef Attribute Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ParagraphStyle::Reader {
public:
  typedef ParagraphStyle Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getAlignment() const;

  inline float getLineSpacing() const;

  inline float getFirstLineHeadIndent() const;

  inline float getHeadIndent() const;

  inline float getTailIndent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ParagraphStyle::Builder {
public:
  typedef ParagraphStyle Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getAlignment();
  inline void setAlignment( ::uint8_t value);

  inline float getLineSpacing();
  inline void setLineSpacing(float value);

  inline float getFirstLineHeadIndent();
  inline void setFirstLineHeadIndent(float value);

  inline float getHeadIndent();
  inline void setHeadIndent(float value);

  inline float getTailIndent();
  inline void setTailIndent(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ParagraphStyle::Pipeline {
public:
  typedef ParagraphStyle Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CommandData::Reader {
public:
  typedef CommandData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCommand() const;
  inline  ::capnp::Text::Reader getCommand() const;

  inline bool hasArgs() const;
  inline  ::capnp::Text::Reader getArgs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CommandData::Builder {
public:
  typedef CommandData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCommand();
  inline  ::capnp::Text::Builder getCommand();
  inline void setCommand( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCommand(unsigned int size);
  inline void adoptCommand(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCommand();

  inline bool hasArgs();
  inline  ::capnp::Text::Builder getArgs();
  inline void setArgs( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initArgs(unsigned int size);
  inline void adoptArgs(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownArgs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CommandData::Pipeline {
public:
  typedef CommandData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RangeAttributesPair::Reader {
public:
  typedef RangeAttributesPair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLocation() const;

  inline  ::uint64_t getLength() const;

  inline bool hasAttributes() const;
  inline  ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>::Reader getAttributes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RangeAttributesPair::Builder {
public:
  typedef RangeAttributesPair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLocation();
  inline void setLocation( ::uint64_t value);

  inline  ::uint64_t getLength();
  inline void setLength( ::uint64_t value);

  inline bool hasAttributes();
  inline  ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>::Builder getAttributes();
  inline void setAttributes( ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>::Builder initAttributes(unsigned int size);
  inline void adoptAttributes(::capnp::Orphan< ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>> disownAttributes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RangeAttributesPair::Pipeline {
public:
  typedef RangeAttributesPair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LibraryEntry::Reader {
public:
  typedef LibraryEntry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

  inline bool hasParentDirectoryBookmark() const;
  inline  ::capnp::Text::Reader getParentDirectoryBookmark() const;

  inline bool hasLastPathComponent() const;
  inline  ::capnp::Text::Reader getLastPathComponent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LibraryEntry::Builder {
public:
  typedef LibraryEntry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

  inline bool hasParentDirectoryBookmark();
  inline  ::capnp::Text::Builder getParentDirectoryBookmark();
  inline void setParentDirectoryBookmark( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initParentDirectoryBookmark(unsigned int size);
  inline void adoptParentDirectoryBookmark(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownParentDirectoryBookmark();

  inline bool hasLastPathComponent();
  inline  ::capnp::Text::Builder getLastPathComponent();
  inline void setLastPathComponent( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initLastPathComponent(unsigned int size);
  inline void adoptLastPathComponent(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownLastPathComponent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LibraryEntry::Pipeline {
public:
  typedef LibraryEntry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LibraryRegistry::Reader {
public:
  typedef LibraryRegistry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLibraries() const;
  inline  ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>::Reader getLibraries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LibraryRegistry::Builder {
public:
  typedef LibraryRegistry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLibraries();
  inline  ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>::Builder getLibraries();
  inline void setLibraries( ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>::Builder initLibraries(unsigned int size);
  inline void adoptLibraries(::capnp::Orphan< ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>> disownLibraries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LibraryRegistry::Pipeline {
public:
  typedef LibraryRegistry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LocationDataPair::Reader {
public:
  typedef LocationDataPair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLocation() const;

  inline bool hasData() const;
  inline  ::capnp::Data::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LocationDataPair::Builder {
public:
  typedef LocationDataPair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLocation();
  inline void setLocation( ::uint64_t value);

  inline bool hasData();
  inline  ::capnp::Data::Builder getData();
  inline void setData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LocationDataPair::Pipeline {
public:
  typedef LocationDataPair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PlatformUrlPair::Reader {
public:
  typedef PlatformUrlPair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPlatform() const;
  inline  ::capnp::Text::Reader getPlatform() const;

  inline bool hasUrl() const;
  inline  ::capnp::Text::Reader getUrl() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PlatformUrlPair::Builder {
public:
  typedef PlatformUrlPair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPlatform();
  inline  ::capnp::Text::Builder getPlatform();
  inline void setPlatform( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPlatform(unsigned int size);
  inline void adoptPlatform(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPlatform();

  inline bool hasUrl();
  inline  ::capnp::Text::Builder getUrl();
  inline void setUrl( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initUrl(unsigned int size);
  inline void adoptUrl(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownUrl();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PlatformUrlPair::Pipeline {
public:
  typedef PlatformUrlPair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OuterDocMultiAttachment::Reader {
public:
  typedef OuterDocMultiAttachment Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFileType() const;
  inline  ::capnp::Text::Reader getFileType() const;

  inline bool hasLocations() const;
  inline  ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>::Reader getLocations() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OuterDocMultiAttachment::Builder {
public:
  typedef OuterDocMultiAttachment Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFileType();
  inline  ::capnp::Text::Builder getFileType();
  inline void setFileType( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFileType(unsigned int size);
  inline void adoptFileType(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFileType();

  inline bool hasLocations();
  inline  ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>::Builder getLocations();
  inline void setLocations( ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>::Builder initLocations(unsigned int size);
  inline void adoptLocations(::capnp::Orphan< ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>> disownLocations();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OuterDocMultiAttachment::Pipeline {
public:
  typedef OuterDocMultiAttachment Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OuterDocPlugin::Reader {
public:
  typedef OuterDocPlugin Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasImplementations() const;
  inline  ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>::Reader getImplementations() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OuterDocPlugin::Builder {
public:
  typedef OuterDocPlugin Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasImplementations();
  inline  ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>::Builder getImplementations();
  inline void setImplementations( ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>::Builder initImplementations(unsigned int size);
  inline void adoptImplementations(::capnp::Orphan< ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>> disownImplementations();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OuterDocPlugin::Pipeline {
public:
  typedef OuterDocPlugin Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OuterLoopAttributedString::Reader {
public:
  typedef OuterLoopAttributedString Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasString() const;
  inline  ::capnp::Text::Reader getString() const;

  inline bool hasAttributes() const;
  inline  ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>::Reader getAttributes() const;

  inline bool hasAttachments() const;
  inline  ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>::Reader getAttachments() const;

  inline bool hasPlugins() const;
  inline  ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>::Reader getPlugins() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OuterLoopAttributedString::Builder {
public:
  typedef OuterLoopAttributedString Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasString();
  inline  ::capnp::Text::Builder getString();
  inline void setString( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initString(unsigned int size);
  inline void adoptString(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownString();

  inline bool hasAttributes();
  inline  ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>::Builder getAttributes();
  inline void setAttributes( ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>::Builder initAttributes(unsigned int size);
  inline void adoptAttributes(::capnp::Orphan< ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>> disownAttributes();

  inline bool hasAttachments();
  inline  ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>::Builder getAttachments();
  inline void setAttachments( ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>::Builder initAttachments(unsigned int size);
  inline void adoptAttachments(::capnp::Orphan< ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>> disownAttachments();

  inline bool hasPlugins();
  inline  ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>::Builder getPlugins();
  inline void setPlugins( ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>::Builder initPlugins(unsigned int size);
  inline void adoptPlugins(::capnp::Orphan< ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>> disownPlugins();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OuterLoopAttributedString::Pipeline {
public:
  typedef OuterLoopAttributedString Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UUID::Reader {
public:
  typedef UUID Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLow() const;

  inline  ::uint64_t getHigh() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UUID::Builder {
public:
  typedef UUID Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLow();
  inline void setLow( ::uint64_t value);

  inline  ::uint64_t getHigh();
  inline void setHigh( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UUID::Pipeline {
public:
  typedef UUID Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RangeIDPair::Reader {
public:
  typedef RangeIDPair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLocation() const;

  inline  ::uint64_t getLength() const;

  inline bool hasId() const;
  inline  ::UUID::Reader getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RangeIDPair::Builder {
public:
  typedef RangeIDPair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLocation();
  inline void setLocation( ::uint64_t value);

  inline  ::uint64_t getLength();
  inline void setLength( ::uint64_t value);

  inline bool hasId();
  inline  ::UUID::Builder getId();
  inline void setId( ::UUID::Reader value);
  inline  ::UUID::Builder initId();
  inline void adoptId(::capnp::Orphan< ::UUID>&& value);
  inline ::capnp::Orphan< ::UUID> disownId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RangeIDPair::Pipeline {
public:
  typedef RangeIDPair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::UUID::Pipeline getId();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LocationCanvasPair::Reader {
public:
  typedef LocationCanvasPair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLocation() const;

  inline bool hasId() const;
  inline  ::UUID::Reader getId() const;

  inline  ::uint32_t getWidth() const;

  inline  ::uint32_t getHeight() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LocationCanvasPair::Builder {
public:
  typedef LocationCanvasPair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLocation();
  inline void setLocation( ::uint64_t value);

  inline bool hasId();
  inline  ::UUID::Builder getId();
  inline void setId( ::UUID::Reader value);
  inline  ::UUID::Builder initId();
  inline void adoptId(::capnp::Orphan< ::UUID>&& value);
  inline ::capnp::Orphan< ::UUID> disownId();

  inline  ::uint32_t getWidth();
  inline void setWidth( ::uint32_t value);

  inline  ::uint32_t getHeight();
  inline void setHeight( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LocationCanvasPair::Pipeline {
public:
  typedef LocationCanvasPair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::UUID::Pipeline getId();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RuntimeOuterDoc::Reader {
public:
  typedef RuntimeOuterDoc Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAttributedString() const;
  inline  ::OuterLoopAttributedString::Reader getAttributedString() const;

  inline bool hasElements() const;
  inline  ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>::Reader getElements() const;

  inline bool hasCanvases() const;
  inline  ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>::Reader getCanvases() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RuntimeOuterDoc::Builder {
public:
  typedef RuntimeOuterDoc Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAttributedString();
  inline  ::OuterLoopAttributedString::Builder getAttributedString();
  inline void setAttributedString( ::OuterLoopAttributedString::Reader value);
  inline  ::OuterLoopAttributedString::Builder initAttributedString();
  inline void adoptAttributedString(::capnp::Orphan< ::OuterLoopAttributedString>&& value);
  inline ::capnp::Orphan< ::OuterLoopAttributedString> disownAttributedString();

  inline bool hasElements();
  inline  ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>::Builder getElements();
  inline void setElements( ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>::Builder initElements(unsigned int size);
  inline void adoptElements(::capnp::Orphan< ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>> disownElements();

  inline bool hasCanvases();
  inline  ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>::Builder getCanvases();
  inline void setCanvases( ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>::Builder initCanvases(unsigned int size);
  inline void adoptCanvases(::capnp::Orphan< ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>> disownCanvases();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RuntimeOuterDoc::Pipeline {
public:
  typedef RuntimeOuterDoc Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::OuterLoopAttributedString::Pipeline getAttributedString();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool FontProperties::Reader::hasFamily() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FontProperties::Builder::hasFamily() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader FontProperties::Reader::getFamily() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder FontProperties::Builder::getFamily() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FontProperties::Builder::setFamily( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder FontProperties::Builder::initFamily(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FontProperties::Builder::adoptFamily(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> FontProperties::Builder::disownFamily() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float FontProperties::Reader::getSize() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float FontProperties::Builder::getSize() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FontProperties::Builder::setSize(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t FontProperties::Reader::getWeight() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FontProperties::Builder::getWeight() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FontProperties::Builder::setWeight( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool FontProperties::Reader::getItalic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool FontProperties::Builder::getItalic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void FontProperties::Builder::setItalic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ColorValue::Reader::getRed() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ColorValue::Builder::getRed() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ColorValue::Builder::setRed( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ColorValue::Reader::getGreen() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ColorValue::Builder::getGreen() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ColorValue::Builder::setGreen( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ColorValue::Reader::getBlue() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ColorValue::Builder::getBlue() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ColorValue::Builder::setBlue( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ColorValue::Reader::getAlpha() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ColorValue::Builder::getAlpha() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void ColorValue::Builder::setAlpha( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::Attribute::Which Attribute::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::Attribute::Which Attribute::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Attribute::Reader::isFont() const {
  return which() == Attribute::FONT;
}
inline bool Attribute::Builder::isFont() {
  return which() == Attribute::FONT;
}
inline bool Attribute::Reader::hasFont() const {
  if (which() != Attribute::FONT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Attribute::Builder::hasFont() {
  if (which() != Attribute::FONT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::FontProperties::Reader Attribute::Reader::getFont() const {
  KJ_IREQUIRE((which() == Attribute::FONT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::FontProperties>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::FontProperties::Builder Attribute::Builder::getFont() {
  KJ_IREQUIRE((which() == Attribute::FONT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::FontProperties>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Attribute::Builder::setFont( ::FontProperties::Reader value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::FONT);
  ::capnp::_::PointerHelpers< ::FontProperties>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::FontProperties::Builder Attribute::Builder::initFont() {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::FONT);
  return ::capnp::_::PointerHelpers< ::FontProperties>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Attribute::Builder::adoptFont(
    ::capnp::Orphan< ::FontProperties>&& value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::FONT);
  ::capnp::_::PointerHelpers< ::FontProperties>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::FontProperties> Attribute::Builder::disownFont() {
  KJ_IREQUIRE((which() == Attribute::FONT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::FontProperties>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Attribute::Reader::isForegroundColor() const {
  return which() == Attribute::FOREGROUND_COLOR;
}
inline bool Attribute::Builder::isForegroundColor() {
  return which() == Attribute::FOREGROUND_COLOR;
}
inline  ::Color Attribute::Reader::getForegroundColor() const {
  KJ_IREQUIRE((which() == Attribute::FOREGROUND_COLOR),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::Color>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::Color Attribute::Builder::getForegroundColor() {
  KJ_IREQUIRE((which() == Attribute::FOREGROUND_COLOR),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::Color>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Attribute::Builder::setForegroundColor( ::Color value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::FOREGROUND_COLOR);
  _builder.setDataField< ::Color>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Attribute::Reader::isBackgroundColor() const {
  return which() == Attribute::BACKGROUND_COLOR;
}
inline bool Attribute::Builder::isBackgroundColor() {
  return which() == Attribute::BACKGROUND_COLOR;
}
inline bool Attribute::Reader::hasBackgroundColor() const {
  if (which() != Attribute::BACKGROUND_COLOR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Attribute::Builder::hasBackgroundColor() {
  if (which() != Attribute::BACKGROUND_COLOR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ColorValue::Reader Attribute::Reader::getBackgroundColor() const {
  KJ_IREQUIRE((which() == Attribute::BACKGROUND_COLOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ColorValue>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ColorValue::Builder Attribute::Builder::getBackgroundColor() {
  KJ_IREQUIRE((which() == Attribute::BACKGROUND_COLOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ColorValue>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Attribute::Builder::setBackgroundColor( ::ColorValue::Reader value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::BACKGROUND_COLOR);
  ::capnp::_::PointerHelpers< ::ColorValue>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ColorValue::Builder Attribute::Builder::initBackgroundColor() {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::BACKGROUND_COLOR);
  return ::capnp::_::PointerHelpers< ::ColorValue>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Attribute::Builder::adoptBackgroundColor(
    ::capnp::Orphan< ::ColorValue>&& value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::BACKGROUND_COLOR);
  ::capnp::_::PointerHelpers< ::ColorValue>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ColorValue> Attribute::Builder::disownBackgroundColor() {
  KJ_IREQUIRE((which() == Attribute::BACKGROUND_COLOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ColorValue>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Attribute::Reader::isUnderline() const {
  return which() == Attribute::UNDERLINE;
}
inline bool Attribute::Builder::isUnderline() {
  return which() == Attribute::UNDERLINE;
}
inline bool Attribute::Reader::getUnderline() const {
  KJ_IREQUIRE((which() == Attribute::UNDERLINE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline bool Attribute::Builder::getUnderline() {
  KJ_IREQUIRE((which() == Attribute::UNDERLINE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void Attribute::Builder::setUnderline(bool value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::UNDERLINE);
  _builder.setDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline bool Attribute::Reader::isStrikethrough() const {
  return which() == Attribute::STRIKETHROUGH;
}
inline bool Attribute::Builder::isStrikethrough() {
  return which() == Attribute::STRIKETHROUGH;
}
inline bool Attribute::Reader::getStrikethrough() const {
  KJ_IREQUIRE((which() == Attribute::STRIKETHROUGH),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline bool Attribute::Builder::getStrikethrough() {
  KJ_IREQUIRE((which() == Attribute::STRIKETHROUGH),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void Attribute::Builder::setStrikethrough(bool value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::STRIKETHROUGH);
  _builder.setDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline bool Attribute::Reader::isSuperscript() const {
  return which() == Attribute::SUPERSCRIPT;
}
inline bool Attribute::Builder::isSuperscript() {
  return which() == Attribute::SUPERSCRIPT;
}
inline bool Attribute::Reader::getSuperscript() const {
  KJ_IREQUIRE((which() == Attribute::SUPERSCRIPT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline bool Attribute::Builder::getSuperscript() {
  KJ_IREQUIRE((which() == Attribute::SUPERSCRIPT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void Attribute::Builder::setSuperscript(bool value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::SUPERSCRIPT);
  _builder.setDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline bool Attribute::Reader::isSubscript() const {
  return which() == Attribute::SUBSCRIPT;
}
inline bool Attribute::Builder::isSubscript() {
  return which() == Attribute::SUBSCRIPT;
}
inline bool Attribute::Reader::getSubscript() const {
  KJ_IREQUIRE((which() == Attribute::SUBSCRIPT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline bool Attribute::Builder::getSubscript() {
  KJ_IREQUIRE((which() == Attribute::SUBSCRIPT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void Attribute::Builder::setSubscript(bool value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::SUBSCRIPT);
  _builder.setDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline bool Attribute::Reader::isLink() const {
  return which() == Attribute::LINK;
}
inline bool Attribute::Builder::isLink() {
  return which() == Attribute::LINK;
}
inline bool Attribute::Reader::hasLink() const {
  if (which() != Attribute::LINK) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Attribute::Builder::hasLink() {
  if (which() != Attribute::LINK) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Attribute::Reader::getLink() const {
  KJ_IREQUIRE((which() == Attribute::LINK),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Attribute::Builder::getLink() {
  KJ_IREQUIRE((which() == Attribute::LINK),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Attribute::Builder::setLink( ::capnp::Text::Reader value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::LINK);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Attribute::Builder::initLink(unsigned int size) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::LINK);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Attribute::Builder::adoptLink(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::LINK);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Attribute::Builder::disownLink() {
  KJ_IREQUIRE((which() == Attribute::LINK),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Attribute::Reader::isParagraph() const {
  return which() == Attribute::PARAGRAPH;
}
inline bool Attribute::Builder::isParagraph() {
  return which() == Attribute::PARAGRAPH;
}
inline bool Attribute::Reader::hasParagraph() const {
  if (which() != Attribute::PARAGRAPH) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Attribute::Builder::hasParagraph() {
  if (which() != Attribute::PARAGRAPH) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ParagraphStyle::Reader Attribute::Reader::getParagraph() const {
  KJ_IREQUIRE((which() == Attribute::PARAGRAPH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ParagraphStyle>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ParagraphStyle::Builder Attribute::Builder::getParagraph() {
  KJ_IREQUIRE((which() == Attribute::PARAGRAPH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ParagraphStyle>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Attribute::Builder::setParagraph( ::ParagraphStyle::Reader value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::PARAGRAPH);
  ::capnp::_::PointerHelpers< ::ParagraphStyle>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ParagraphStyle::Builder Attribute::Builder::initParagraph() {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::PARAGRAPH);
  return ::capnp::_::PointerHelpers< ::ParagraphStyle>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Attribute::Builder::adoptParagraph(
    ::capnp::Orphan< ::ParagraphStyle>&& value) {
  _builder.setDataField<Attribute::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Attribute::PARAGRAPH);
  ::capnp::_::PointerHelpers< ::ParagraphStyle>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ParagraphStyle> Attribute::Builder::disownParagraph() {
  KJ_IREQUIRE((which() == Attribute::PARAGRAPH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ParagraphStyle>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t ParagraphStyle::Reader::getAlignment() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t ParagraphStyle::Builder::getAlignment() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ParagraphStyle::Builder::setAlignment( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float ParagraphStyle::Reader::getLineSpacing() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float ParagraphStyle::Builder::getLineSpacing() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ParagraphStyle::Builder::setLineSpacing(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float ParagraphStyle::Reader::getFirstLineHeadIndent() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float ParagraphStyle::Builder::getFirstLineHeadIndent() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ParagraphStyle::Builder::setFirstLineHeadIndent(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float ParagraphStyle::Reader::getHeadIndent() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float ParagraphStyle::Builder::getHeadIndent() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void ParagraphStyle::Builder::setHeadIndent(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float ParagraphStyle::Reader::getTailIndent() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float ParagraphStyle::Builder::getTailIndent() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void ParagraphStyle::Builder::setTailIndent(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool CommandData::Reader::hasCommand() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CommandData::Builder::hasCommand() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CommandData::Reader::getCommand() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CommandData::Builder::getCommand() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CommandData::Builder::setCommand( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CommandData::Builder::initCommand(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CommandData::Builder::adoptCommand(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CommandData::Builder::disownCommand() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CommandData::Reader::hasArgs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CommandData::Builder::hasArgs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CommandData::Reader::getArgs() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CommandData::Builder::getArgs() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CommandData::Builder::setArgs( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CommandData::Builder::initArgs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void CommandData::Builder::adoptArgs(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CommandData::Builder::disownArgs() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint64_t RangeAttributesPair::Reader::getLocation() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t RangeAttributesPair::Builder::getLocation() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RangeAttributesPair::Builder::setLocation( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t RangeAttributesPair::Reader::getLength() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t RangeAttributesPair::Builder::getLength() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RangeAttributesPair::Builder::setLength( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool RangeAttributesPair::Reader::hasAttributes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RangeAttributesPair::Builder::hasAttributes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>::Reader RangeAttributesPair::Reader::getAttributes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>::Builder RangeAttributesPair::Builder::getAttributes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RangeAttributesPair::Builder::setAttributes( ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>::Builder RangeAttributesPair::Builder::initAttributes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RangeAttributesPair::Builder::adoptAttributes(
    ::capnp::Orphan< ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>> RangeAttributesPair::Builder::disownAttributes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Attribute,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LibraryEntry::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LibraryEntry::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader LibraryEntry::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder LibraryEntry::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LibraryEntry::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder LibraryEntry::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void LibraryEntry::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> LibraryEntry::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LibraryEntry::Reader::hasParentDirectoryBookmark() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LibraryEntry::Builder::hasParentDirectoryBookmark() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader LibraryEntry::Reader::getParentDirectoryBookmark() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder LibraryEntry::Builder::getParentDirectoryBookmark() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LibraryEntry::Builder::setParentDirectoryBookmark( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder LibraryEntry::Builder::initParentDirectoryBookmark(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void LibraryEntry::Builder::adoptParentDirectoryBookmark(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> LibraryEntry::Builder::disownParentDirectoryBookmark() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LibraryEntry::Reader::hasLastPathComponent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool LibraryEntry::Builder::hasLastPathComponent() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader LibraryEntry::Reader::getLastPathComponent() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder LibraryEntry::Builder::getLastPathComponent() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void LibraryEntry::Builder::setLastPathComponent( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder LibraryEntry::Builder::initLastPathComponent(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void LibraryEntry::Builder::adoptLastPathComponent(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> LibraryEntry::Builder::disownLastPathComponent() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool LibraryRegistry::Reader::hasLibraries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LibraryRegistry::Builder::hasLibraries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>::Reader LibraryRegistry::Reader::getLibraries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>::Builder LibraryRegistry::Builder::getLibraries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LibraryRegistry::Builder::setLibraries( ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>::Builder LibraryRegistry::Builder::initLibraries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void LibraryRegistry::Builder::adoptLibraries(
    ::capnp::Orphan< ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>> LibraryRegistry::Builder::disownLibraries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LibraryEntry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t LocationDataPair::Reader::getLocation() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t LocationDataPair::Builder::getLocation() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LocationDataPair::Builder::setLocation( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool LocationDataPair::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LocationDataPair::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader LocationDataPair::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder LocationDataPair::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LocationDataPair::Builder::setData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder LocationDataPair::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void LocationDataPair::Builder::adoptData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> LocationDataPair::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PlatformUrlPair::Reader::hasPlatform() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PlatformUrlPair::Builder::hasPlatform() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader PlatformUrlPair::Reader::getPlatform() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder PlatformUrlPair::Builder::getPlatform() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PlatformUrlPair::Builder::setPlatform( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder PlatformUrlPair::Builder::initPlatform(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void PlatformUrlPair::Builder::adoptPlatform(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> PlatformUrlPair::Builder::disownPlatform() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PlatformUrlPair::Reader::hasUrl() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PlatformUrlPair::Builder::hasUrl() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader PlatformUrlPair::Reader::getUrl() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder PlatformUrlPair::Builder::getUrl() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PlatformUrlPair::Builder::setUrl( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder PlatformUrlPair::Builder::initUrl(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void PlatformUrlPair::Builder::adoptUrl(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> PlatformUrlPair::Builder::disownUrl() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool OuterDocMultiAttachment::Reader::hasFileType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool OuterDocMultiAttachment::Builder::hasFileType() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader OuterDocMultiAttachment::Reader::getFileType() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder OuterDocMultiAttachment::Builder::getFileType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void OuterDocMultiAttachment::Builder::setFileType( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder OuterDocMultiAttachment::Builder::initFileType(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void OuterDocMultiAttachment::Builder::adoptFileType(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> OuterDocMultiAttachment::Builder::disownFileType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool OuterDocMultiAttachment::Reader::hasLocations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool OuterDocMultiAttachment::Builder::hasLocations() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>::Reader OuterDocMultiAttachment::Reader::getLocations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>::Builder OuterDocMultiAttachment::Builder::getLocations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void OuterDocMultiAttachment::Builder::setLocations( ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>::Builder OuterDocMultiAttachment::Builder::initLocations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void OuterDocMultiAttachment::Builder::adoptLocations(
    ::capnp::Orphan< ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>> OuterDocMultiAttachment::Builder::disownLocations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LocationDataPair,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool OuterDocPlugin::Reader::hasImplementations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool OuterDocPlugin::Builder::hasImplementations() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>::Reader OuterDocPlugin::Reader::getImplementations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>::Builder OuterDocPlugin::Builder::getImplementations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void OuterDocPlugin::Builder::setImplementations( ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>::Builder OuterDocPlugin::Builder::initImplementations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void OuterDocPlugin::Builder::adoptImplementations(
    ::capnp::Orphan< ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>> OuterDocPlugin::Builder::disownImplementations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PlatformUrlPair,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool OuterLoopAttributedString::Reader::hasString() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool OuterLoopAttributedString::Builder::hasString() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader OuterLoopAttributedString::Reader::getString() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder OuterLoopAttributedString::Builder::getString() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void OuterLoopAttributedString::Builder::setString( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder OuterLoopAttributedString::Builder::initString(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void OuterLoopAttributedString::Builder::adoptString(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> OuterLoopAttributedString::Builder::disownString() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool OuterLoopAttributedString::Reader::hasAttributes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool OuterLoopAttributedString::Builder::hasAttributes() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>::Reader OuterLoopAttributedString::Reader::getAttributes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>::Builder OuterLoopAttributedString::Builder::getAttributes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void OuterLoopAttributedString::Builder::setAttributes( ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>::Builder OuterLoopAttributedString::Builder::initAttributes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void OuterLoopAttributedString::Builder::adoptAttributes(
    ::capnp::Orphan< ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>> OuterLoopAttributedString::Builder::disownAttributes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::RangeAttributesPair,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool OuterLoopAttributedString::Reader::hasAttachments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool OuterLoopAttributedString::Builder::hasAttachments() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>::Reader OuterLoopAttributedString::Reader::getAttachments() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>::Builder OuterLoopAttributedString::Builder::getAttachments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void OuterLoopAttributedString::Builder::setAttachments( ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>::Builder OuterLoopAttributedString::Builder::initAttachments(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void OuterLoopAttributedString::Builder::adoptAttachments(
    ::capnp::Orphan< ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>> OuterLoopAttributedString::Builder::disownAttachments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocMultiAttachment,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool OuterLoopAttributedString::Reader::hasPlugins() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool OuterLoopAttributedString::Builder::hasPlugins() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>::Reader OuterLoopAttributedString::Reader::getPlugins() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>::Builder OuterLoopAttributedString::Builder::getPlugins() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void OuterLoopAttributedString::Builder::setPlugins( ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>::Builder OuterLoopAttributedString::Builder::initPlugins(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void OuterLoopAttributedString::Builder::adoptPlugins(
    ::capnp::Orphan< ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>> OuterLoopAttributedString::Builder::disownPlugins() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::OuterDocPlugin,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::uint64_t UUID::Reader::getLow() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UUID::Builder::getLow() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UUID::Builder::setLow( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t UUID::Reader::getHigh() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UUID::Builder::getHigh() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void UUID::Builder::setHigh( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t RangeIDPair::Reader::getLocation() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t RangeIDPair::Builder::getLocation() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RangeIDPair::Builder::setLocation( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t RangeIDPair::Reader::getLength() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t RangeIDPair::Builder::getLength() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RangeIDPair::Builder::setLength( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool RangeIDPair::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RangeIDPair::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::UUID::Reader RangeIDPair::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::UUID>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::UUID::Builder RangeIDPair::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::UUID>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::UUID::Pipeline RangeIDPair::Pipeline::getId() {
  return  ::UUID::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void RangeIDPair::Builder::setId( ::UUID::Reader value) {
  ::capnp::_::PointerHelpers< ::UUID>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::UUID::Builder RangeIDPair::Builder::initId() {
  return ::capnp::_::PointerHelpers< ::UUID>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RangeIDPair::Builder::adoptId(
    ::capnp::Orphan< ::UUID>&& value) {
  ::capnp::_::PointerHelpers< ::UUID>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::UUID> RangeIDPair::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::UUID>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t LocationCanvasPair::Reader::getLocation() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t LocationCanvasPair::Builder::getLocation() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LocationCanvasPair::Builder::setLocation( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool LocationCanvasPair::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LocationCanvasPair::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::UUID::Reader LocationCanvasPair::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::UUID>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::UUID::Builder LocationCanvasPair::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::UUID>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::UUID::Pipeline LocationCanvasPair::Pipeline::getId() {
  return  ::UUID::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LocationCanvasPair::Builder::setId( ::UUID::Reader value) {
  ::capnp::_::PointerHelpers< ::UUID>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::UUID::Builder LocationCanvasPair::Builder::initId() {
  return ::capnp::_::PointerHelpers< ::UUID>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LocationCanvasPair::Builder::adoptId(
    ::capnp::Orphan< ::UUID>&& value) {
  ::capnp::_::PointerHelpers< ::UUID>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::UUID> LocationCanvasPair::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::UUID>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t LocationCanvasPair::Reader::getWidth() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LocationCanvasPair::Builder::getWidth() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void LocationCanvasPair::Builder::setWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t LocationCanvasPair::Reader::getHeight() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t LocationCanvasPair::Builder::getHeight() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void LocationCanvasPair::Builder::setHeight( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool RuntimeOuterDoc::Reader::hasAttributedString() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RuntimeOuterDoc::Builder::hasAttributedString() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::OuterLoopAttributedString::Reader RuntimeOuterDoc::Reader::getAttributedString() const {
  return ::capnp::_::PointerHelpers< ::OuterLoopAttributedString>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::OuterLoopAttributedString::Builder RuntimeOuterDoc::Builder::getAttributedString() {
  return ::capnp::_::PointerHelpers< ::OuterLoopAttributedString>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::OuterLoopAttributedString::Pipeline RuntimeOuterDoc::Pipeline::getAttributedString() {
  return  ::OuterLoopAttributedString::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void RuntimeOuterDoc::Builder::setAttributedString( ::OuterLoopAttributedString::Reader value) {
  ::capnp::_::PointerHelpers< ::OuterLoopAttributedString>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::OuterLoopAttributedString::Builder RuntimeOuterDoc::Builder::initAttributedString() {
  return ::capnp::_::PointerHelpers< ::OuterLoopAttributedString>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RuntimeOuterDoc::Builder::adoptAttributedString(
    ::capnp::Orphan< ::OuterLoopAttributedString>&& value) {
  ::capnp::_::PointerHelpers< ::OuterLoopAttributedString>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::OuterLoopAttributedString> RuntimeOuterDoc::Builder::disownAttributedString() {
  return ::capnp::_::PointerHelpers< ::OuterLoopAttributedString>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RuntimeOuterDoc::Reader::hasElements() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool RuntimeOuterDoc::Builder::hasElements() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>::Reader RuntimeOuterDoc::Reader::getElements() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>::Builder RuntimeOuterDoc::Builder::getElements() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void RuntimeOuterDoc::Builder::setElements( ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>::Builder RuntimeOuterDoc::Builder::initElements(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void RuntimeOuterDoc::Builder::adoptElements(
    ::capnp::Orphan< ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>> RuntimeOuterDoc::Builder::disownElements() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::RangeIDPair,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool RuntimeOuterDoc::Reader::hasCanvases() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool RuntimeOuterDoc::Builder::hasCanvases() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>::Reader RuntimeOuterDoc::Reader::getCanvases() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>::Builder RuntimeOuterDoc::Builder::getCanvases() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void RuntimeOuterDoc::Builder::setCanvases( ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>::Builder RuntimeOuterDoc::Builder::initCanvases(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void RuntimeOuterDoc::Builder::adoptCanvases(
    ::capnp::Orphan< ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>> RuntimeOuterDoc::Builder::disownCanvases() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LocationCanvasPair,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}


CAPNP_END_HEADER

